<!DOCTYPE HTML>
<html id="html">
<head>
<style>
	@font-face {
	  font-family: 'font';
	  src: url('/client/font.woff') format('woff'),
	   url('/client/font.ttf') format('truetype');
	}  		
	html * {
		font-family: font;
	}
</style>
<meta name="viewport" content="user-scalable=no, width=device-width,  initial-scale=0.5, minimum-scale=0.5,  maximum-scale=0.5"/>
<title>Demo</title>
</head>

<body>
<canvas id="easel" style="top: 2px; left: 2px; width:16px; height:16px; position: fixed; background-color: #fff; display:none; z-index:99999;"></canvas>
<canvas id="noiseCanvas" style="top: 50px; left: 50px; width:250px; height:250px; position: fixed; display: none; background-color: rgba(0,0,0,0); z-index:9999;"></canvas>
<canvas id="myCanvas" style="top:0px;left:0px;position: fixed;background-color:#859ba9"></canvas>
<script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="/node_modules/simplex-noise/simplex-noise.js"></script>

<img src="/client/spritesheet.png" id="spritesheet" style="position:fixed;top:-1000px;display:none;"></img>
<img src="/client/pickheld.png" id="pickheld" style="position:fixed;top:-1000px;display:none;"></img>

<audio id="meadow" preload="all">
   <source src="/client/meadow.mp3">
</audio>
<audio id="birdsong" preload="all" loop>
   <source src="/client/birdsong.mp3">
</audio>
<audio id="reel" preload="all">
   <source src="/client/reel.mp3">
</audio>
<audio id="rockbreak" preload="all">
   <source src="/client/rockbreak.mp3">
</audio>
<audio id="woodbreak" preload="all">
   <source src="/client/woodbreak.mp3">
</audio>

<div id="login" style="background-color: rgba(255,255,255,0.2); padding:15px; position: fixed; top:20px; right:20px; z-index:1000; font-size: 26px; text-shadow: 2px 2px 0 #000; color: white">
		<center>
		<span style="font-size: 32px;"><u>Log In</u></span><br><br>
		Username&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="username" id="username@12837123"></input><br><br>
		Password&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<input type="password" id="password@12837123"></input><br><br>
		<button id="logIn" style="font-size: 16px" onclick="socket.emit('login',{username:document.getElementById('username@12837123').value,password:document.getElementById('password@12837123').value});">Log In</button>
		<button id="register" style="font-size: 16px" onclick="window.location.href = '/new'">Create Account</button>
		<pre id="error" style="text-shadow: 1.5px 1.5px 0 #000; color: red; font-size: 20px;"></pre>
</div>
	
	
</body>

<script>
	var canvas = document.getElementById('myCanvas');
	var context = canvas.getContext('2d');
	
	var socket = io();
	
	//Noise canvas
	var noiseCanvas = document.getElementById("noiseCanvas");
	var noiseContext = noiseCanvas.getContext("2d");
	var map = false;
	
	var noiseX = 0;
	var noiseY = 0;
	var noiseComplete = true;
	var noiseLimit = -1;
	var noiseScale = 1;
	
	var tileCache = {};
	
	function tileCacheFetch(x,y) {
		cx = Math.floor(x/16);
		cy = Math.floor(y/16);
		if (tileCache[cx+","+cy]) {
			return tileCache[cx+","+cy][x+","+y];
		}
	}
	
	//async
	function updateTileCache() {
		for (chunk in tileCache) {
			if (tileCache[chunk]) {
				tileCache[chunk].safe = false;
			}
		}
		
		//Additions
		cx = Math.floor(toTilePos(players[username].playerX)/16);
		cy = Math.floor(toTilePos(players[username].playerY)/16);
		
		for (ccx = cx-1; ccx < cx+2; ccx++) {
			for (ccy = cy-1; ccy < cy+2; ccy++) {
				if (!tileCache[ccx+","+ccy]) {
					//Temp setting to avoid repeated rqs
					tileCache[ccx+","+ccy] = {"safe":true};
					
					//Populating cache
					for (x = (ccx*16); x < (ccx*16)+16; x++) {
						for (y = (ccy*16); y < (ccy*16)+16; y++) {
							tileCache[ccx+","+ccy][x+","+y] = blackBox(x,y);
						}
					}
				} else {
					tileCache[ccx+","+ccy].safe = true;
				}
			}
		}
		
		
		//Removals
		for (chunk in tileCache) {
			if (tileCache[chunk]) {
				if (!tileCache[chunk].safe) {
					tileCache[chunk] = null;
				}
			}
		}
	}
	
	function scaleNoiseCanvas() {
		noiseCanvas.width = window.innerWidth-100; 
		noiseCanvas.height = window.innerHeight-100;

		noiseCanvas.style.width = Math.round(noiseCanvas.width)+"px";
		noiseCanvas.style.height = Math.round(noiseCanvas.height)+"px";
	}

	scaleNoiseCanvas();
	
	function viewNoise(noiseScale=1,limit=10000) {
		if (!noiseComplete || noiseX != 0) {
			return;
		}
	
		noiseX = 0;
		noiseY = 0;
		noiseComplete = false;
		noiseLimit = limit;
		noiseScale = noiseScale;
	}
	
	function mapDec(n) {
		return (n+1)/2
	}
	
	function updateNoiseMap() {
		if (noiseComplete) {
			false;
		}
		
		count = 0;
		for (var z = 0; noiseX < (noiseCanvas.width/noiseScale); noiseX++) {
			if (noiseY != 0) {
				noiseX--;
			}
			for (var z = 0; noiseY < (noiseCanvas.height/noiseScale); noiseY++) {
				//Get output color
				tile = blackBox(noiseX-Math.floor((noiseCanvas.width/2)/noiseScale),noiseY-Math.floor((noiseCanvas.height/2)/noiseScale));
				if (tile.mapcolor) {
					noiseContext.fillStyle = tile.mapcolor;
				} else {
					noiseContext.fillStyle = tile.color;
				}
				noiseContext.fillRect(noiseX*noiseScale,noiseY*noiseScale,noiseScale,noiseScale);
				count++;
				if (count > noiseLimit) {
					return;
				}
			}
			noiseY = 0;
		}
		noiseComplete = true;
		noiseContext.fillStyle = "red";
		noiseContext.globalAlpha = 0.005;
		if (players[username]) {
			noiseContext.fillRect(toTilePos(players[username].playerX)*noiseScale+Math.floor((noiseCanvas.width/2)/noiseScale)-(8*noiseScale),toTilePos(players[username].playerY)*noiseScale+Math.floor((noiseCanvas.height/2)/noiseScale)-(8*noiseScale),noiseScale*16,noiseScale*16);
		}
		noiseContext.globalAlpha = 1;
	}
	
	//Easel
	var easel = document.getElementById('easel');
	var easelContext = easel.getContext('2d');
	
	function scaleEasel() {
		easel.width = 16; 
		easel.height = 16;

		easel.style.width = Math.round(easel.width)+"px";
		easel.style.height = Math.round(easel.height)+"px";
	}

	scaleEasel();
	
	//Key Constants
	LEFT = 37;
	A = 65;
	
	RIGHT = 39;
	D = 68;
	
	UP = 38;
	W = 87;
	
	DOWN = 40;
	S = 83;
	
	R = 82;
	E = 69;
	C = 67;
	
	SPACE = 32;
	ENTER = 13;
	SHIFT = 16;
	CTRL = 17;
	ALT = 18;
	
	F5 = 116;
	F12 = 123;
	
	
	//Variables
	var spritesheet = document.getElementById("spritesheet");
	
	var players = {};
	var username = "";
	var touch = false;
	var mouseX = 0;
	var mouseY = 0;
	var keysPressed = {};
	var debugMenu = 0;
	var gameRun = true;
	
	var serverSessionID = 0;
	var leftRight = 0;
	var upDown = 0;
	var autoSaveOpacity = 0;
	var timeout = 0;
	var tileScale = 48;
	var playerSize = 25;
	
	var cameraX = 0;
	var cameraY = 0;
	var colors = ["#3DE646","#3DE646","#3DE847","#3CE245","#3BDF44","#3CE245","#3BE044","#3BE044","#3BE044","#3BE044","#3BE044","#3CE044"];
	var lcolors = ["#3DF656","#3DF656","#3DF857","#3CF255","#3BEF54","#3CF255","#3BF054","#3BF054","#3BF054","#3BF054","#3BF054","#3CF054"];
	var dcolors = ["#2DD636","#2DD636","#2DD837","#2CD235","#2BCF34","#2CD235","#2BD034","#2BD034","#2BD034","#2BD034","#2BD034","#2CD034"];
	var sandcolors = ["#FFFF96","#FFFF90","#FFFF9f","#FFFF8a","#FFFFa3","#FFFF9e","#FFFF9a","#FFFF97","#FFFF88","#FFFF96","#FFFF99","#FFFF90"];
	var globalTimer = 0;
	var structures;
	var antistructures = [];
	var particles = [];
	var particlesLength = 0;
	var clientDelay = 0;
	var serverDelay = 0;
	var money = 0;
	var guest = true;
	var soundStarted = false;
	var last30ClientFPS = [];
	var last30ServerUPS = [];
	var ping = -1;
	var pingStart;
	var pingIndex = 0;
	var dotdotdot = "";
	var controlsMenuClosed = false;
	
	var simplex = new SimplexNoise(Math.trunc(randInt(10000000000)));
	
	var inventory = {
		slot:0,
		slotMax:9,
	}
	
	setInterval(function (){
		pingIndex++;
		pingStart = performance.now();
		socket.emit("pping",pingIndex);
	},1000);
	
	socket.on("ppong",function (data) {
		if (data == pingIndex) {
			if (typeof pingStart !== "undefined") {
				ping = Math.floor(performance.now() - pingStart);
			}
		} else {
			ping = 999;
		}
	});
	
	var textures = {
		"rock":[0,0,16,16],
		"crate":[0,16,16,16],
		"crateOpen":[16,16,16,16],
		"wallStone":[48,16,16,16],
		"pickaxe":[48,32,16,16],
		"axe":[32,32,16,16],
		"rod":[48,48,16,16],
		"hoe":[32,48,16,16],
		"can":[64,48,16,16],
		"tilled":[16,48,16,16],
		"tilledWet":[0,48,16,16],
		"sign":[0,64,16,16],
		"money":[64,16,16,16],
		"sandpebble":[32,64,16,16],
		"pebble":[16,64,16,16],
		"grass":[48,64,16,16],
		"tree":[80,32,16,48],
		"treeneck":[80,57,16,12],
	}

	function newPlayer(username) {
		players[username] = {
			playerX:0,
			playerY:0,
			color:"white",
			keysPressed:{},
		}
	}

	//Function to make the canvas fill the window
	function scaleCanvas() {
		canvas.width = window.innerWidth; 
		canvas.height = window.innerHeight;

		canvas.style.width = Math.round(canvas.width)+"px";
		canvas.style.height = Math.round(canvas.height)+"px";
	}

	scaleCanvas();
	
	//Load cookie stored account
	if (localStorage.getItem("username") == undefined || localStorage.getItem("username") == "" || localStorage.getItem("username") == "null" || localStorage.getItem("username") == null) {
		socket.emit("newGuest");
	} else {
		if (localStorage.getItem("password") == undefined || localStorage.getItem("password") == "" || localStorage.getItem("password") == "null" || localStorage.getItem("password") == null) {
			socket.emit("newGuest");
		} else {
			//setTimeout(function() {socket.emit("login",{username:localStorage.getItem("username"),password:localStorage.getItem("password")});},2000);
			socket.emit("login",{username:localStorage.getItem("username"),password:localStorage.getItem("password")});
		}
	}
	
	function playerTile(name,x,y) {
		if (Math.floor(players[name].playerX/tileScale) == x && Math.floor((players[name].playerY)/tileScale) == y) {
			return true;
		}
		return false;
	}

	function drawPlayers() {
		//For each player in the players array
		for (var player in players) {
			if (players[player].active) {
				
				//            xScale, xSkew          translateX, Y
				//context.setTransform(1, 0, -0.1, 1, 0, 0);
				//                        yScew, yScale
				//Replace this to a movement checker for all players so it dosen't only work on the client's player
				
				
				//Building
				if (players[player].keysPressed[SHIFT]) {
				
					if (player == username) {
						context.strokeStyle = "red";
						context.fillStyle = "red";
					} else {
						context.strokeStyle = "gray";
						context.fillStyle = "gray";
					}
					
					bx = 0;
					by = 0;
					
					if (players[player].keysPressed[LEFT] || players[player].keysPressed[A]) {
						bx = -1;
					} else {
						if (players[player].keysPressed[RIGHT] || players[player].keysPressed[D]) {
							bx = 1;
						}
					}
					if (players[player].keysPressed[UP] || players[player].keysPressed[W]) {
						by = -1;
					} else {
						if (players[player].keysPressed[DOWN] || players[player].keysPressed[S]) {
							by = 1;
						}
					}
					
					if (bx != 0 || by != 0) {
						context.globalAlpha = 0.15;
						context.fillRect(tileAlign(players[player].playerX)+cameraX+bx*tileScale, tileAlign(players[player].playerY)+cameraY+by*tileScale,tileScale,tileScale);
						context.beginPath();
						context.globalAlpha = 0.3;
						
						context.moveTo(tileAlign(players[player].playerX)+cameraX+bx*tileScale, tileAlign(players[player].playerY)+cameraY+by*tileScale);
						context.lineTo(tileAlign(players[player].playerX)+cameraX+bx*tileScale, tileAlign(players[player].playerY)+cameraY+tileScale+by*tileScale);
						context.lineTo(tileAlign(players[player].playerX)+cameraX+tileScale+bx*tileScale, tileAlign(players[player].playerY)+cameraY+tileScale+by*tileScale);
						context.lineTo(tileAlign(players[player].playerX)+cameraX+tileScale+bx*tileScale, tileAlign(players[player].playerY)+cameraY+by*tileScale);
						context.lineTo(tileAlign(players[player].playerX)+cameraX+bx*tileScale, tileAlign(players[player].playerY)+cameraY+by*tileScale);
						
						context.stroke();
					}
					context.globalAlpha = 1;
				}
				
				
				//Player + Skew
				if (players[player].keysPressed[LEFT] || players[player].keysPressed[A]) {
					leftRight = -3;
				} else {
					if (players[player].keysPressed[RIGHT] || players[player].keysPressed[D]) {
						leftRight = 3;
					} else {
						leftRight = 0;
					}
				}
				if (players[player].keysPressed[UP] || players[player].keysPressed[W]) {
					upDown = -3;
				} else {
					if (players[player].keysPressed[DOWN] || players[player].keysPressed[S]) {
						upDown = 3;
					} else {
						upDown = 0;
					}
				}
			
				
				//Player Shadow
				context.fillStyle = "black";
				context.globalAlpha = 0.2;
				if (leftRight != 3) {
					context.fillRect(players[player].playerX+leftRight+cameraX-playerSize/2-2,players[player].playerY+cameraY-4,28-leftRight,7-upDown/9);
				} else {
					context.fillRect(players[player].playerX+cameraX-playerSize/2-2,players[player].playerY+cameraY-4,31,7-upDown/9);
				}
				context.globalAlpha = 1;
				
				//Player Skew
				context.strokeStyle = "black";
				context.fillStyle = players[player].color;
				context.lineWidth = 2;
				context.beginPath();
				
				//tl
				context.moveTo(players[player].playerX+leftRight+cameraX-playerSize/2, players[player].playerY+upDown+cameraY-playerSize*2);
				//tr
				context.lineTo(players[player].playerX+(playerSize/2)+leftRight+cameraX, players[player].playerY+upDown+cameraY-playerSize*2);
				//br
				context.lineTo(players[player].playerX+(playerSize/2)+cameraX, players[player].playerY+playerSize*2+cameraY-playerSize*2);
				//bl
				context.lineTo(players[player].playerX+cameraX-playerSize/2, players[player].playerY+playerSize*2+cameraY-playerSize*2);
				//tl
				context.lineTo(players[player].playerX+leftRight+cameraX-playerSize/2, players[player].playerY+upDown+cameraY-playerSize*2);
			
			
				context.fill();
				context.stroke();
				context.closePath();
				
				//if (players[player].username != username) {
					context.font = 24+'px font';
					context.textAlign = "center";
				
					context.fillStyle = "white";
					context.strokeStyle = "black";
					
					context.strokeText(players[player].username, players[player].playerX+cameraX, players[player].playerY-10+cameraY-playerSize*2);
					context.fillText(players[player].username, players[player].playerX+cameraX, players[player].playerY-10+cameraY-playerSize*2);
					
					context.textAlign = "start";
				//}
				
				//Fishing
				if (players[player].fishing && players[player].fishing.isFishing) {
					context.strokeStyle = "black";
					context.beginPath();
					context.moveTo(players[player].playerX+cameraX,players[player].playerY+cameraY);
					context.quadraticCurveTo(cameraX+players[player].fishing.line.x,100,players[player].fishing.line.x+cameraX,players[player].fishing.line.y+cameraY);
					context.stroke();
					
					context.fillStyle = "red";
					context.fillRect(cameraX+players[player].fishing.line.x-3,cameraY+players[player].fishing.line.y-3,6,6);
					context.fillStyle = "white";
					context.fillRect(cameraX+players[player].fishing.line.x-3,cameraY+players[player].fishing.line.y-1,6,2);
					
					if (players[player].inventory[inventory.slot].type != "rod") {
						if (players[player].fishing) {
							socket.emit("fishing:stop");
						}
					}
				}
				
				//ALT Alignment
				if (debugMenu == 2) {
					context.globalAlpha = 0.3;
					context.beginPath();
					
					if (player == username) {
						context.strokeStyle = "blue";
					} else {
						context.strokeStyle = "red";
					}
					
					//Target
					context.arc(players[player].playerX+cameraX,players[player].playerY+cameraY,5,0,2*Math.PI);
					context.arc(players[player].playerX+cameraX,players[player].playerY+cameraY,1,0,2*Math.PI);
					
					//Crosshair
					context.moveTo(players[player].playerX+cameraX,canvas.height);
					context.lineTo(players[player].playerX+cameraX,0);
					context.moveTo(canvas.width,players[player].playerY+cameraY);
					context.lineTo(0,players[player].playerY+cameraY);
					
					//Grid Pos
					context.moveTo(tileAlign(players[player].playerX)+cameraX, tileAlign(players[player].playerY)+cameraY);
					context.lineTo(tileAlign(players[player].playerX)+cameraX, tileAlign(players[player].playerY)+cameraY+tileScale);
					context.lineTo(tileAlign(players[player].playerX)+cameraX+tileScale, tileAlign(players[player].playerY)+cameraY+tileScale);
					context.lineTo(tileAlign(players[player].playerX)+cameraX+tileScale, tileAlign(players[player].playerY)+cameraY);
					context.lineTo(tileAlign(players[player].playerX)+cameraX, tileAlign(players[player].playerY)+cameraY);
					
					context.stroke();
					
					//Spawn Line
					if (player == username) {
						context.beginPath();
						context.strokeStyle = "yellow";
						
						context.moveTo(players[username].playerX+cameraX,players[username].playerY+cameraY);
						context.lineTo(cameraX,cameraY);
						context.stroke();
					} else {
						//Tracers
						context.beginPath();
						context.strokeStyle = "magenta";
						
						context.moveTo(players[username].playerX+cameraX,players[username].playerY+cameraY);
						context.lineTo(players[player].playerX+cameraX,players[player].playerY+cameraY);
						context.stroke();
					}
					
					context.globalAlpha = 1;
				}
			}
		}
	}
	
	//Draws the top left message
	function drawText() {
		if (autoSaveOpacity > 0) {
			context.font = 30+'px font';
			context.globalAlpha = autoSaveOpacity;
			context.fillStyle = "black";
			context.fillText("> "+message,15+2,50+2);
			context.fillStyle = "white";
			context.fillText("> "+message,15,50);
			context.globalAlpha = 1;
			
			autoSaveOpacity -=0.01;
		}
	}
	
	function drawControls() {
		if (controlsMenuClosed) {
			return;
		}
		
		context.globalAlpha = 0.4;
		context.fillStyle = "black";
		context.fillRect(0,0,canvas.width,canvas.height);
		context.globalAlpha = 1;
		
		for (mtx = 0; mtx < 11; mtx++) {
			for (mty = 0; mty < 5; mty++) {
				context.drawImage(spritesheet, 16,32,16,16, canvas.width/3-25+(mtx*tileScale), canvas.height/3-35+(mty*tileScale), tileScale, tileScale);
			}
		}
		
		context.globalAlpha-= 0.4;
		context.fillStyle = "black";
		context.fillRect(canvas.width/3-25,canvas.height/3-35,11*tileScale,5*tileScale);
		
		
		context.globalAlpha+= 0.4;
		context.strokeRect(canvas.width/3-25,canvas.height/3-35,11*tileScale,5*tileScale);
		
		
		mx = canvas.width/3;
		my = canvas.height/3;
		mi = 30;
		ms = 2;
		
		context.textAlign = "left";
		context.font = 26+'px font';
		
		fillTextShadow(context, "Controls:", mx, my, ms);
		fillTextShadow(context, "    Movement ----------- WASD/Arrow Keys", mx, my+mi, ms);
		fillTextShadow(context, "    Sprint ------------  Spacebar", mx, my+(mi*2), ms);
		fillTextShadow(context, "    Build/Use ---------  Shift+(WASD/Arrow Keys)+Click", mx, my+(mi*3), ms);
		fillTextShadow(context, "    Select Item -------  Scroll/Numkeys 1-9", mx, my+(mi*4), ms);
		fillTextShadow(context, "    Open Map ----------  M", mx, my+(mi*5), ms);
		fillTextShadow(context, "    Debug Menu --------  C", mx, my+(mi*6), ms);
		
		if (mouseBox(canvas.width/3-25+10.5*tileScale-17, my-5-35, tileScale, tileScale)) {
			context.globalAlpha = 0.7;
		} else {
			context.globalAlpha = 1;
		}
		context.font = 32+'px font';
		fillTextShadow(context, "X", canvas.width/3-25+10.5*tileScale, my-5, ms);
	}
	
	function fillTextShadow(ctx,text,tx,ty,offset) {
		ctx.fillStyle = "black";
		ctx.fillText(text,tx+offset,ty+offset);		
		ctx.fillStyle = "white";
		ctx.fillText(text,tx,ty);
	}
	
	function drawTerrain() {
		//Generated Relative Tile Drawing
		topLeftTileX = (toTilePos(players[username].playerX) - Math.trunc((canvas.width/tileScale)/2));
		topLeftTileY = (toTilePos(players[username].playerY) - Math.trunc((canvas.height/tileScale)/2));
		bottomRightTileX = topLeftTileX+canvas.width/tileScale+1;
		bottomRightTileY = topLeftTileY+canvas.height/tileScale+1+2; //+2 for trees
		
		for (x = topLeftTileX; x < bottomRightTileX; x++) {
			for (y = topLeftTileY; y < bottomRightTileY; y++) {
				if ((x >= 0 && y >= 0) || true) {
					//tile = blackBox(x,y);
					tile = tileCacheFetch(x,y);
					if (!tile) {
						return;
					}
					
					if (tile.lake) {
					//	continue;
					}
					
					//Flat color tiles
					context.fillStyle = tile.color;
					context.fillRect(x*tileScale+cameraX,y*tileScale+cameraY,tileScale,tileScale);
					
					//Antistructure
					error = false;
					for (index = 0; index < antistructures.length; index++) {
						if (antistructures[index].x == x && antistructures[index].y == y) {
							error = true;
							break;
						}
					}
					if (!error) {
					
						if (tile.sandpebble) {
							context.drawImage(spritesheet,textures["sandpebble"][0],textures["sandpebble"][1],textures["sandpebble"][2],textures["sandpebble"][3],x*tileScale+cameraX,y*tileScale+cameraY,tileScale,tileScale);
						}							
						
						if (tile.grass) {
							context.drawImage(spritesheet,textures["grass"][0],textures["grass"][1],textures["grass"][2],textures["grass"][3],x*tileScale+cameraX,y*tileScale+cameraY,tileScale,tileScale);
						}		
						
						if (tile.rock) {
							context.drawImage(spritesheet,textures["rock"][0],textures["rock"][1],textures["rock"][2],textures["rock"][3],x*tileScale+cameraX,y*tileScale+cameraY,tileScale,tileScale);
						}							
						
						if (tile.tree) {
							context.drawImage(spritesheet,textures["tree"][0],textures["tree"][1],textures["tree"][2],textures["tree"][3],x*tileScale+cameraX+tile.treeX,y*tileScale+cameraY-tileScale*2+tile.treeY,tileScale,tileScale*3);
						}	
						
						if (tile.lake) {
							//Create an animation offest
							arb = Math.trunc(tile.hash*30);
							if (tile.hash > 0.5) {
								arb = -arb;
							}
							arb = 0;
							
							//Decide on the frame and previous frame ghosting
							if (globalTimer % 60+arb >= 0 && globalTimer % 60+arb < 10) {
								animationX = 24;
								midframeX = 40;
								midframeOpacity = Math.abs(globalTimer % 60+arb-10)/20;
							} else {
								if (globalTimer % 60+arb >= 10 && globalTimer % 60+arb < 20) {
									animationX = 40;
									midframeX = 24;
									midframeOpacity = Math.abs(globalTimer % 60+arb-20)/20;
								} else {
									if (globalTimer % 60+arb >= 20 && globalTimer % 60+arb < 30) {
										animationX = 56;
										midframeX = 40;
										midframeOpacity = Math.abs(globalTimer % 60+arb-30)/20;
									} else {
										if (globalTimer % 60+arb >= 30 && globalTimer % 60+arb < 40) {
											animationX = 72;
											midframeX = 56;
											midframeOpacity = Math.abs(globalTimer % 60+arb-40)/20;
										} else {
											if (globalTimer % 60+arb >= 40 && globalTimer % 60+arb < 50) {
												animationX = 56;
												midframeX = 72;
												midframeOpacity = Math.abs(globalTimer % 60+arb-50)/20;
											} else {
												animationX = 40;
												midframeX = 56;
												midframeOpacity = Math.abs(globalTimer % 60+arb-60)/20;
											}
										}
									}
								}
							}
							
							//Drawing Tile
							context.drawImage(spritesheet,animationX,0,16,16,x*tileScale+cameraX,y*tileScale+cameraY,tileScale,tileScale);
							
							//Drawing ghost tile
							context.globalAlpha = midframeOpacity;
							context.drawImage(spritesheet,midframeX,0,16,16,x*tileScale+cameraX,y*tileScale+cameraY,tileScale,tileScale);
							context.globalAlpha = 1;
						}
						
						//if (tile.expandUp) {
						//	context.drawImage(tile.expandUp, x*tileScale+cameraX,(y-1)*tileScale+cameraY)
						//}
						
					}
					
					if (debugMenu == 2) {
						if (x % 16 == 0) {
							context.globalAlpha=0.5;
							context.fillStyle = "white";
							context.fillRect(x*tileScale+cameraX,y*tileScale+cameraY,5,tileScale);
							context.globalAlpha=1;
						}
						if (y % 16 == 0) {
							context.globalAlpha=0.5;
							context.fillStyle = "white";
							context.fillRect(x*tileScale+cameraX,y*tileScale+cameraY,tileScale,5);
							context.globalAlpha=1;
						}
					}
				}
			}
		}
		
		//Particles
		particlesLength = 0;
		for (var particle in particles) {
			for (var subParticle in particles[particle]) {
				particlesLength++;
			
				context.globalAlpha = particles[particle][subParticle].opacity;
				
				context.drawImage(spritesheet,particles[particle][subParticle].spritex,particles[particle][subParticle].spritey,particles[particle][subParticle].spriteScale,particles[particle][subParticle].spriteScale,particles[particle][subParticle].x+cameraX-particles[particle][subParticle].scale/2 , particles[particle][subParticle].y+cameraY-particles[particle][subParticle].scale/2 , particles[particle][subParticle].scale , particles[particle][subParticle].scale);	
				
				context.globalAlpha = 1;
			}
			context.globalAlpha = 1;
		}
		
		//Structures
		for (var structure in structures) {
			//on screen
			if ((structures[structure].x*tileScale+cameraX+tileScale > 0 && structures[structure].x*tileScale+cameraX < canvas.width) && (structures[structure].y*tileScale+cameraY+tileScale > 0 && structures[structure].y*tileScale+cameraY < canvas.height)) {
			
				texture = textures[structures[structure].type];
				
				//Draw Structure Texture
				context.drawImage(spritesheet,texture[0],texture[1],texture[2],texture[3],structures[structure].x*tileScale+cameraX,structures[structure].y*tileScale+cameraY,tileScale,tileScale);
				
				//Display Sign Text
				if (structures[structure].type == "sign" && playerTile(username,structures[structure].x,structures[structure].y)) {
					message = structures[structure].text;
					autoSaveOpacity = 1;
				}
			}
		}
	}
	
	// Coords -> BlackBox -> Everything about that tile's generation
	function blackBox(x,y,end) {
		//List of features
		var tile = {hash:0,rock:false,color:"",lake:false,sandpebble:false,test:false,tree:false,empty:true};
		
		//Simplex noise
		tile.seed = simplex.noise2D(x*1000, y*1000);
		tile.clayhash = simplex.noise2D(x/20+1000, y/20+1000);
		tile.lakehash = simplex.noise2D(x/20, y/20);
		tile.rockhash = simplex.noise2D(x/1, y/1);
		tile.rockhash2 = simplex.noise2D(x/1 + 20123, y/1 + 20123);
		tile.rockhash3 = simplex.noise2D(x/1 - 20123, y/1 - 20123);
		tile.pebblehash = simplex.noise2D(x*100, y*100);
		tile.subbiomehash = simplex.noise2D(x/100, y/100);
		tile.grasshash = simplex.noise2D(x/40-1001, y/40-1001);
		
		
		let h = (1 - mapDec(simplex.noise2D(x / 80, y / 80)))*			//Octaves
				(1 - mapDec(simplex.noise2D(x / 40 + 1532, y / 40))/2)*
				(1 - mapDec(simplex.noise2D(x / 20 + 2524, y / 20))/4);
				
		let impulse = (1 - mapDec(simplex.noise2D(x / 160 + 2102, y / 160)))*			//Octaves
				(1 - mapDec(simplex.noise2D(x / 40 - 1532, y / 40))/2)*
				(1 - mapDec(simplex.noise2D(x / 20 - 2524, y / 20))/4);
				
		let global = (1 - mapDec(simplex.noise2D(x/5 / 80 + 2102, y/5 / 80)))*			//Octaves
				(1 - mapDec(simplex.noise2D(x/2.5 / 40 - 1532, y/2.5 / 40))/2)*
				(1 - mapDec(simplex.noise2D(x/1 / 20 - 2524, y/1 / 20))/4);
				
				
		//if (global > 0.35) {
		//	bw = 0;
		//	tile.mapcolor = "rgb("+bw*255+","+bw*255+","+bw*255+")";
		//}
					
		h *= h;

		if (impulse > 0.35) {
			impulse = 0;
		} else {
			impulse = 1
		}				
		
		//if (h*(global+0.5) > 0.45 * (1+(((impulse)/1)-(1/2)))) {
		oh = h;
		if (h*impulse > 0.45*((global*3)-0.25)) {
			h = 0
		} else {
			h = 1;
		}				
		
		if (h == 1 && (oh*impulse > 0.40*((global*3)-0.25))) {
			h = 0.2;
		}
		
		if (h == 1 && (h*impulse > 0.40*((global*3)-0.25))) {
			h = 0.4;
		}				
		
		if (h == 1 && oh > 0.4) {
			h = 0.3;
		}
		
		//Simplex noise
		tile.lakehash = simplex.noise2D(x/20, y/20);
		tile.subbiomehash = simplex.noise2D(x/100, y/100);
		
		if (h && tile.subbiomehash > -0.5) {
			//Default subbiome
			if (tile.lakehash < -0.7) {
				h = 0.1;
			} else {
				if (tile.lakehash < -0.55) {
					h = 0.5
				}
			}
		}
		
		if (h == 0 || h == 0.1) {
			tile.lake = true;
			tile.mapcolor = "#13c";
			tile.empty = false;
		} else {
			if (h == 0.5 || h == 0.2) {
				tile.color = sandcolors[Math.floor(Math.abs(tile.rockhash*sandcolors.length))];
				tile.sand = true;
			} else {
				if (h == 0.4) {
					tile.color = dcolors[Math.floor(Math.abs(tile.rockhash*dcolors.length))];
				} else {
					if (h == 0.3) {
						tile.color = lcolors[Math.floor(Math.abs(tile.rockhash*lcolors.length))];
					} else {
						tile.color = colors[Math.floor(Math.abs(tile.rockhash*colors.length))];
					}
				}
			}
		}
			
		if (tile.subbiomehash > -0.5) {
			if (tile.rockhash < -0.9 && h > 0.2) {
				tile.rock = true;
				tile.mapcolor = "#000";
				tile.empty = false;
			}
		}
		
		if (tile.empty) {
			if (!tile.sand) {
				if (tile.rockhash > 0.5*(Math.abs(tile.grasshash)+0.5) && tile.subbiomehash > 0) {
					tile.tree = true;
					tile.treeX = -Math.abs(Math.floor(Math.round(tile.rockhash2*15) / 4)*4);
					tile.treeY = -Math.abs(Math.floor(Math.round(tile.rockhash3*15) / 4)*4);
					tile.mapcolor = "#730";
				} else {
					if (tile.grasshash < -0.5) {
						if (tile.pebblehash < 0) {
							tile.grass = true;
						}
					}
				}
			} else {
				if (tile.clayhash < -0.45 && tile.pebblehash < 0) {
					tile.sandpebble = true;
				}
			}
		}
		
		if (!end && !tile.lake && false) {
			if (blackBox(x,y-1,true).lake) {
				//Create procedural graphic for expanding up
				
				if (tile.seed > 0) {
					if (tile.seed > 0.5) {
						lens = [2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2];
					} else {
						lens = [2,1,1,1,1,2,2,2,2,2,2,2,1,1,1,2];
					} 
				} else {
					if (tile.seed > -0.5) {
						lens = [2,1,1,1,1,2,2,2,3,3,3,3,3,3,3,2];
					} else {
						lens = [2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2];
					} 
				}
				var graphic = easelContext.createImageData(16, 16);
				
				myColor = hexToRgb(tile.color);
				
				//Uint8ClampedArray, rgba data for each pixel
				for (var p = 0; p < graphic.data.length; p+=4) {
					alpha = 0;

					if (lens[(p/4) % 16] >= Math.floor((p/4) / 16)) {
						alpha = 255; //-(Math.floor((p/4) / 16)*25);
					}
				
					graphic.data[p] = myColor.r;
					graphic.data[p+1] = myColor.g;
					graphic.data[p+2] = myColor.b;
					graphic.data[p+3] = alpha;
				}
				
				createImageBitmap(graphic, 0, 0, 16, 16,{resizeWidth: 48, resizeHeight: 48, resizeQuality: "pixelated", imageOrientation: "flipY"}).then(function (imgBitmap) {
					tileCacheFetch(x,y).expandUp = imgBitmap;
				});
				
				easelContext.putImageData(graphic, 0, 0);
			}
		}
			
		//Output
		return tile;
	}
	
	Math.seededRandom = function(max, min) {
		max = max || 1;
		min = min || 0;
	 
		Math.seed = (Math.seed * 9301 + 49297) % 233280;
		var rnd = Math.seed / 233280;
	 
		return Math.trunc(min + rnd * (max - min));
	}
	
	function hexToRgb(hex) {
		if (hex.length < 6) {
			if (hex.charAt(0) == "#") {
				hex = hex.substr(1);
			}
			hex = hex.split('').map(function (hex) {
				return hex + hex;
			}).join('');
		}
	
		var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		return result ? {
			r: parseInt(result[1], 16),
			g: parseInt(result[2], 16),
			b: parseInt(result[3], 16)
		} : null;
	}
	
	function drawInventory() {
		//Numkey Inventory Selection
		for (index = 0; index < inventory.slotMax; index++) {
			if (keysPressed[49+index]) {
				inventory.slot = 0+index;
			}
		}
	
	
		//Draw
		x = canvas.width/2-((tileScale*1.15+15)*inventory.slotMax)/2;
		y = 30;
		
		context.strokeStyle = "white";
		
		for (index = 0; index < inventory.slotMax; index++) {
			//Slot
			context.fillStyle = "lightgray";
			context.globalAlpha = 0.5;
			if (index == inventory.slot) {
				context.globalAlpha = 1;
				context.fillStyle = "white";
			}
			context.drawImage(spritesheet,0,32,16,16,x+(tileScale*1.15+15)*index,y,tileScale*1.15,tileScale*1.15);
			
			//Item
			if (players[username].inventory[index]) {
				context.drawImage(spritesheet,textures[players[username].inventory[index].type][0],textures[players[username].inventory[index].type][1],16,16,x+(tileScale*1.15+15)*index+(tileScale*0.15)/2,y+(tileScale*0.15)/2,tileScale,tileScale);
			}
			
			//Outline
			if (index == inventory.slot) {
				context.globalAlpha = 0.4;
				context.strokeRect(x+(tileScale*1.15+15)*index,y,tileScale*1.15,tileScale*1.15);
			}
		}
		
		context.globalAlpha = 1;
		
		yShift = 0;
		if (guest || debugMenu) {
			yShift = 275;
		}
		
		//Draw money
		context.globalAlpha = 1;
		context.drawImage(spritesheet,textures["money"][0],textures["money"][1],textures["money"][2],textures["money"][3],canvas.width-tileScale*1.5,tileScale/2+yShift,tileScale,tileScale);
		
		context.textAlign = "right";
		context.font = 30+'px font';
		context.fillStyle = "black";
		context.fillText(money, canvas.width-tileScale*1.4+2, tileScale+tileScale/7+2+yShift);		
		context.fillStyle = "white";
		context.fillText(money, canvas.width-tileScale*1.4, tileScale+tileScale/7+yShift);
		
		context.textAlign = "left";

	}
	
	function toTilePos(pixel) {
		return Math.floor(pixel/tileScale);
	}
	
	function tileAlign(pixel) {
		return Math.floor(pixel/tileScale)*tileScale;
	}
	
	function adjustCamera() {
		targetCameraX = ((-players[username].playerX)+(toTilePos((canvas.width/2)))*tileScale)-playerSize+tileScale/2;
		targetCameraY = ((-players[username].playerY)+(toTilePos((canvas.height/2)))*tileScale)-playerSize*2+tileScale;
		cameraX = targetCameraX//+tileScale*5;
		cameraY = targetCameraY//+tileScale*5;
	}
	
	function drawInfoText() {
		if (debugMenu) {
			last30ClientFPS.push(Math.floor(1000/clientDelay));
			if (last30ClientFPS.length > 30) {
				last30ClientFPS.shift();
			}
			last30ServerUPS.push(Math.floor(1000/serverDelay));
			if (last30ServerUPS.length > 30) {
				last30ServerUPS.shift();
			}
		
			context.textAlign = "right";
			context.font = 30+'px font';
			
			context.fillStyle = "black";
			context.fillText(Math.floor(arrayAverage(last30ServerUPS)*10)/10+" serverUPS   "+Math.floor(arrayAverage(last30ClientFPS)*10)/10+" clientFPS   "+particlesLength+"particles   ",canvas.width-10+2,30+2);
			context.fillStyle = "white";
			context.fillText(Math.floor(arrayAverage(last30ServerUPS)*10)/10+" serverUPS   "+Math.floor(arrayAverage(last30ClientFPS)*10)/10+" clientFPS   "+particlesLength+"particles   ",canvas.width-10,30);
			
			context.fillStyle = "black";
			context.fillText(structures.length+"structures   "+antistructures.length+"antistructures",canvas.width-10+2,60+2);
			context.fillStyle = "white";
			context.fillText(structures.length+"structures   "+antistructures.length+"antistructures",canvas.width-10,60);
		
			context.fillStyle = "black";
			context.fillText("chunk: "+Math.floor(toTilePos(players[username].playerX)/16)+"x, "+Math.floor(toTilePos(players[username].playerY)/16)+"y   player: "+toTilePos(players[username].playerX)+"x, "+toTilePos(players[username].playerY)+"y",canvas.width-10+2,90+2);
			context.fillStyle = "white";
			context.fillText("chunk: "+Math.floor(toTilePos(players[username].playerX)/16)+"x, "+Math.floor(toTilePos(players[username].playerY)/16)+"y   player: "+toTilePos(players[username].playerX)+"x, "+toTilePos(players[username].playerY)+"y",canvas.width-10,90);
			
			context.fillStyle = "black";
			context.fillText("online "+(Object.keys(players).length-1)+"   ping "+ping+"ms",canvas.width-10+2,120+2);
			context.fillStyle = "white";
			context.fillText("online "+(Object.keys(players).length-1)+"   ping "+ping+"ms",canvas.width-10,120);
			
			
			context.textAlign = "start";
		}
	}
	
	function arrayAverage(array) {
		var sum = 0;
		for (var i = 0; i < array.length; i++) {
			sum+=array[i];
		}
		return sum/array.length;
	}
	
	socket.on("autosave",function() {
		message = "Game Saved";
		autoSaveOpacity = 1;
	});
	
	socket.on("playsound",function(data) {
		//x:placeTileX
		//y:placeTileY
		sound = document.getElementById(data.sound);
		sound.volume = data.volume;
		sound.play();
	});

	//Whenever a public packet is recived
	socket.on("publicPacket",function(data) {
		//Server Session Change Detection
		if (username != "" && data.serverSessionID != serverSessionID) {
			//username = "";
			//window.location.href = '/';
		}
		
		if (username == "") {
			return;
		}
		
		//Update Player Informaion
		players = [];
		userPlayerIndex = -1;
		for (index = 0; index < data.players.length; index++) {
			//User's player recieved
			if (data.players[index].username == username) {
				userPlayerIndex = index;
				money = 0;
				if (data.players[index].money) {
					money = data.players[index].money;
				}
				
				//Begin game
				if (!gameRun) {
					gameRun = true;
					simplex = new SimplexNoise(Math.trunc(serverSessionID*100000));
					tileCache = {};
				}
			} else {
				newPlayer(data.players[index].username);

				//Updating Relevant Information about the player (no reference)
				players[data.players[index].username] = JSON.parse(JSON.stringify(data.players[index]));
			}
		}
		
		if (userPlayerIndex+1) {
			//Adding the user's player last so always drawn ontop (no reference)
			newPlayer(username);
			players[username] = JSON.parse(JSON.stringify(data.players[userPlayerIndex]));
		}

		serverDelay = data.serverDelay;
		timeout = 0;
	});

	//Whenever a private packet is recived
	socket.on("privatePacket",function(data) {
		structures = data.structures;
		antistructures = data.antistructures;
		particles = data.particles;
	});


	//Main Program Loop
	function progLoop() {
		players[""] = {playerX: 1000, playerY: 1000};
		
		context.clearRect(0,0,canvas.width,canvas.height);
		context.imageSmoothingEnabled = false;

		if (players[username]) {
			updateTileCache();
			if (username == "") {
				adjustCamera();
				drawTerrain();
				
				context.fillStyle = "black";
				context.globalAlpha = 0.2;
				context.fillRect(canvas.width/2-25-212,canvas.height/3-75,400,110);
				context.globalAlpha = 1;
				context.font = 75+'px font';
				context.fillStyle = "black";
				context.fillText("Joining game"+dotdotdot,canvas.width/2+3-212,canvas.height/3+3)
				context.fillStyle = "white";
				context.fillText("Joining game"+dotdotdot,canvas.width/2-212,canvas.height/3);
				
				if (globalTimer % 10 == 0) {
					dotdotdot += ".";
					if (dotdotdot.length > 3) {
						dotdotdot = ".";
					}
				}
				
			} else {
				if (gameRun) {
					gameplayLoop();
				}
			}
		}
		
		updateNoiseMap();
		if (map) {
			context.fillStyle = "#000";
			context.globalAlpha = 0.5;
			context.fillRect(0,0,canvas.width,canvas.height);
			context.globalAlpha = 1
		}
		
		drawControls();
		
		globalTimer++;
		requestAnimationFrame(progLoop);
	}
	
	requestAnimationFrame(progLoop);
	
	function gameplayLoop() {
		adjustCamera();
		drawTerrain();
		drawPlayers();
		
		drawText();
		drawInfoText();
		drawInventory();
		
		socket.emit("updateClientData",{
			keysPressed:keysPressed,
		});
		
		//Timeout Delay
		timeout++;
		if (timeout > 100) {
			username = "";
			window.location.href = '/';
		}
		
		if (typeof start !== "undefined") {
			clientDelay = performance.now() - start;
		}
		start = performance.now();
	}
	
	
	function startMusic() {
		meadow = document.getElementById('meadow');
		meadow.volume = 0.1;
		meadow.play();
		birdsong = document.getElementById('birdsong');
		birdsong.volume = 0.25;
		birdsong.play();
	}
	
	function mouseBox(x,y,sx,sy) {
		if (mouseX < x+sx && 
			mouseY > y && 
			mouseX > x && 
			mouseY < y+sy) {
			
			return true;
		}
		return false;
	}
	
	socket.on("alert",function(data) {
		alert(data);
	});
	
	socket.on("reload",function() {
		username = "";
		window.location.href = '/';
	});
	
	socket.on("loginResponse",function(data) {
		if (data.accepted == true) {
			username = data.username;
			gameRun = false;
			serverSessionID = data.serverSessionID;
			
			if (username.charAt(0) != "_") {
				guest = false;
				if (document.getElementById('username@12837123').value != "") {
					localStorage.setItem("username", document.getElementById('username@12837123').value);
					localStorage.setItem("password", document.getElementById('password@12837123').value);
				}
				endMenu();
			}
			
		} else {
			document.getElementById('error').textContent = data.reason;
		}
	});
	
	socket.on("newResponse",function(data) {
		if (data.accepted == true) {
			if (data.guest) {
				localStorage.setItem("username", data.username);
				localStorage.setItem("password", data.password);
				socket.emit("login",{username:data.username,password:data.password});
			}
		}
	});
	
	//Mouse Input
	$(canvas)
		.bind('touchstart mousedown',function(e){
			e.preventDefault()
			if (e.touches == undefined) {
				mouseX = e.clientX;
				mouseY = e.clientY;
			} else {
				mouseX = parseInt(e.touches[0].pageX);
				mouseY = parseInt(e.touches[0].pageY);
			}
			touch = true;
			
			if (!controlsMenuClosed) {
				controlsMenuClosed = true;
			}
			
			//Dumb idiotic sound protection bypass
			if (!soundStarted) {
				startMusic();
				soundStarted = true;
			}
			
			if (keysPressed[SHIFT] && (keysPressed[LEFT]||keysPressed[A]||keysPressed[RIGHT]||keysPressed[D]||keysPressed[UP]||keysPressed[W]||keysPressed[DOWN]||keysPressed[S])) {
				socket.emit("action",{slot:inventory.slot});
				
				//Cast cooldown (sound)
				if (players[username].inventory[inventory.slot].type == "rod" && !(reel.duration > 0 && !reel.paused)) {
					bx = -1;
					if (players[username].keysPressed[LEFT] || players[username].keysPressed[A]) {
						bx = -1;
					} else {
						if (players[username].keysPressed[RIGHT] || players[username].keysPressed[D]) {
							bx = 1;
						}
					}
					
					socket.emit("fishing:cast",bx);
				}
			}
		})
		
		.bind('touchend mouseup',function(e){
			e.preventDefault()
			touch = false;
		})
		
		.bind('touchmove mousemove',function(e){
			e.preventDefault()
			if (e.touches == undefined) {
				mouseX = e.clientX;
				mouseY = e.clientY;
			} else {
				mouseX = parseInt(e.touches[0].pageX);
				mouseY = parseInt(e.touches[0].pageY);
			}
		});
		
		$('body').on('contextmenu', '#myCanvas', function(e){ return false; });
		
	function endMenu() {
		document.getElementById('login').style.display = "none";
	}
	
	//Keyboard Input
	window.addEventListener("keydown",
		function(e){
			if (e.keyCode != F5 && e.keyCode != F12 && e.keyCode != CTRL && e.keyCode != R) {
				//e.preventDefault();
			}
			
			if (e.keyCode == C) {
				debugMenu++;
				if (debugMenu > 2) {
					debugMenu = 0;
				}
			}
			
			if (e.keyCode == 77) {
				map = !map;
			}
			
			if (map) {
				noiseCanvas.style.display = "";
				viewNoise();
			} else {
				noiseCanvas.style.display = "none";
			}
			
			keysPressed[e.keyCode] = true;
		},
	false);

	window.addEventListener('keyup',
		function(e){
			if (e.keyCode != F5 && e.keyCode != F12 && e.keyCode != CTRL && e.keyCode != R) {
				//e.preventDefault();
			}
			keysPressed[e.keyCode] = false;
		},
	false);
		
	document.getElementById("myCanvas").addEventListener("mousewheel", function() {
		var e = window.event || e; // old IE support
		var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
		if (delta > 0) {
			if (inventory.slot != 0) {
				inventory.slot--;
			} else {
				inventory.slot = inventory.slotMax-1;
			}
		} else {
			if (inventory.slot < inventory.slotMax-1) {
				inventory.slot++;
			} else {
				inventory.slot = 0;
			}
		}
	}, false);
		
	
	function randInt(max){
		return Math.trunc(Math.random() * (max - 0));
	}

</script>
</body>
</html>